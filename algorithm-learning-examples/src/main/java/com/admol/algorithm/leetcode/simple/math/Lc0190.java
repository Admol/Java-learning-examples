package com.admol.algorithm.leetcode.simple.math;

/**
 * 颠倒二进制位
 * 颠倒给定的 32 位无符号整数的二进制位。
 * 示例 1：
 * 输入: 00000010100101000001111010011100
 * 输出: 00111001011110000010100101000000
 * 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 *      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 * 示例 2：
 * 输入：11111111111111111111111111111101
 * 输出：10111111111111111111111111111111
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 *      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 * 提示：
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 * 链接：https://leetcode-cn.com/problems/reverse-bits
 * @author : admol
 * @Date : 2020/6/29
 */
public class Lc0190{
    /**
     * 核心思想: 分治合并
     * 1.反转左右16位
     * 2.反转每个16位中的左右8位
     * 3.反转每个8位中的左右4位
     * 4.反转每个4位中的左右2位
     * 5.反转每个2位中的左右1位
     * 或运算:只要有一个为1, 结果就为1
     *
     * 计算详细步骤:
     * 假设原数字n为: 0000 0010 1001 0100 0001 1110 1001 1100
     * 第一步:反转左右16位
     * n >>> 16: 0000 0000 0000 0000 0000 0010 1001 0100
     * n << 16 : 0001 1110 1001 1100 0000 0000 0000 0000
     * 或运算结果: 0001 1110 1001 1100 0000 0010 1001 0100 (第一步之后n的结果)
     *
     * 第二步:反转每个16位中的左右8位
     * 0xff00ff00对应二进制: 1111 1111 0000 0000 1111 1111 0000 0000
     * 0x00ff00ff对应二进制: 0000 0000 1111 1111 0000 0000 1111 1111
     * 实际计算
     *  n & 0xff00ff00:
     *  0001 1110 1001 1100 0000 0010 1001 0100
     *  &
     *  1111 1111 0000 0000 1111 1111 0000 0000
     *  =
     *  0001 1110 0000 0000 0000 0010 0000 0000 >>> 8  (右移8位)
     *  =
     *  0000 0000 0001 1110 0000 0000 0000 0010
     *
     *  n & 0x00ff00ff:
     *  0001 1110 1001 1100 0000 0010 1001 0100
     *  &
     *  0000 0000 1111 1111 0000 0000 1111 1111
     *  =
     *  0000 0000 1001 1100 0000 0000 1001 0100 << 8
     *  =
     *  1001 1100 0000 0000 1001 0100 0000 0000
     * 求或运算
     * 0000 0000 0001 1110 0000 0000 0000 0010
     * |
     * 1001 1100 0000 0000 1001 0100 0000 0000
     * =
     * 1001 1100 0001 1110 1001 0100 0000 0010 (第二步之后n的结果)
     *
     * 第三步: 反转每个8位中的左右4位
     * 0xf0f0f0f0对应的二进制为:‭1111 0000 1111 0000 1111 0000 1111 0000‬
     * 0x0f0f0f0f对应的二进制为:0000‬ ‭1111 0000 1111 0000 1111 0000 1111
     * n & 0xf0f0f0f0 相当于:
     *  1001 1100 0001 1110 1001 0100 0000 0010  &
     *  ‭1111 0000 1111 0000 1111 0000 1111 0000‬
     * =1001 0000 0001 0000 1001 0000 0000 0000 >>> 4
     * =0000 1001 0000 0001 0000 1001 0000 0000
     *
     * n & 0x0f0f0f0f 相当于:
     *  1001 1100 0001 1110 1001 0100 0000 0010  &
     *  0000‬ ‭1111 0000 1111 0000 1111 0000 1111
     * =1001 1100 0001 1110 0000 0100 0000 0010 << 4
     * =1100 0001 1110 0000 0100 0000 0010 0000
     * 或运算
     *  0000 1001 0000 0001 0000 1001 0000 0000 |
     *  1100 0001 1110 0000 0100 0000 0010 0000
     * =1100 1001 1110 0001 0100 1001 0010 0000  (第三步之后n的结果)
     *
     * 第四步:反转每个4位中的左右2位
     *  0xcccccccc对应的二进制: ‭1100 1100 1100 1100 1100 1100 1100 1100‬
     *  0x33333333对应的二进制: 00‭11 0011 0011 0011 0011 0011 0011 0011‬
     *  n & 0xcccccccc:
     *  1100 1001 1110 0001 0100 1001 0010 0000 &
     *  ‭1100 1100 1100 1100 1100 1100 1100 1100‬
     * =1100 1000 1100 0000 0100 1000 0000 0000 >>> 2
     * =0011 0010 0011 0000 0001 0010 0000 0000
     *  n & 0x33333333:
     *  1100 1001 1110 0001 0100 1001 0010 0000 &
     *  00‭11 0011 0011 0011 0011 0011 0011 0011‬
     *  0000 0001 0010 0001 0000 0001 0010 0000 << 2
     *  0000 0100 1000 0100 0000 0100 1000 0000
     *  或运算
     *  0011 0010 0011 0000 0001 0010 0000 0000 |
     *  0000 0100 1000 0100 0000 0100 1000 0000
     * =0011 0110 1011 0100 0001 0110 1000 0000  (第四步之后n的结果)
     *
     * 第五步:反转每个2位中的左右1位
     * 0xaaaaaaaa表示二进制: ‭1010 1010 1010 1010 1010 1010 1010 1010‬
     * 0x55555555表示二进制: 0‭101 0101 0101 0101 0101 0101 0101 0101‬
     * n & 0xaaaaaaaa:
     * 0011 0110 1011 0100 0001 0110 1000 0000 &
     * ‭1010 1010 1010 1010 1010 1010 1010 1010‬
     * 0010 0010 1010 0000 0000 0010 1000 0000 >>> 1
     * 0001 0001 0101 0000 0000 0001 0100 0000
     * n & 0x55555555:
     * 0011 0110 1011 0100 0001 0110 1000 0000 &
     * 0‭101 0101 0101 0101 0101 0101 0101 0101‬
     * 0001 0100 0001 0100 0001 0100 0000 0000 <<< 1
     * 0010 1000 0010 1000 0010 1000 0000 0000
     * 或运算:
     * 0001 0001 0101 0000 0000 0001 0100 0000 |
     * 0010 1000 0010 1000 0010 1000 0000 0000
     * 0011 1001 0111 1000 0010 1001 0100 0000 (第五步之后n的结果)
     *
     * 合在一起看每次变化的过程:
     * 原数字 0000 0010 1001 0100 0001 1110 1001 1100
     * 第一步 0001 1110 1001 1100 0000 0010 1001 0100
     * 第二步 1001 1100 0001 1110 1001 0100 0000 0010
     * 第三步 1100 1001 1110 0001 0100 1001 0010 0000
     * 第四步 0011 0110 1011 0100 0001 0110 1000 0000
     * 第五步 00‭11 1001 0111 1000 0010 1001 0100 0000‬
     * param n
     * @return
     */
    public static int reverseBits(int n) {
        // 1.经过左右16位反转后为: 0001 1110 1001 1100 0000 0010 1001 0100
        n = (n >>> 16) | (n << 16);
        System.out.println(Integer.toBinaryString(n));
        // 2.经过左右8位反转后为:1001 1100 0001 1110 1001 0100 0000 0010
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
        System.out.println(Integer.toBinaryString(n));
        // 3.反转每个4位中的左右2位: 1100 1001 1110 0001 0100 1001 0010 0000
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        System.out.println(Integer.toBinaryString(n));

        // 4.反转每个4位中的左右2位: 0011 0110 1011 0100 0001 0110 1000 0000
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        System.out.println(Integer.toBinaryString(n));

        // 5.反转每个2位中的左右1位: 00‭11 1001 0111 1000 0010 1001 0100 0000‬
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        System.out.println(Integer.toBinaryString(n));
        return n;
    }
    /**
     * 异或, 相同为0, 不同为1 , 任何数于0异或为任何数 0 ^ n => n
     * 直接颠倒计算每一位的数字
     * 核心思想:
     * 准备一个32位的ans,全部为0,
     * 32位 int 标记 [0 ~ 31] , 如果第i位为1, 颠倒后第31-i位应该为1, 第i位变成31-i的值
     * 比如输入:    00000010100101000001111010011100
     * i=0: ans = 00000000000000000000000000000000
     * i=1: ans = 00000000000000000000000000000000
     * i=2: ans = 00100000000000000000000000000000, 解释: 原数的第2位是1, 颠倒后,ans第31-2位为1
     * i=3: ans = 00110000000000000000000000000000, 解释: 原数的第3位是1, 颠倒后,ans第31-3位为1
     * i=4: ans = 00111000000000000000000000000000, 解释: 原数的第4位是1, 颠倒后,ans第31-4位为1
     * ....
     * @param n
     * @return
     */
    public static int reverseBits4(int n) {
        int ans = 0;
        for(int i = 0; i <32 ; i++){
            //1.判断第i位是否为1, 只需要判断 n & (1 << i) 是否为0就可以了,比如n是 11100011, 判断第0位是否为1,就是 11100011 & (1<<0),
            // 全部写成二进制表示就是 11100011 & (1<<0) ==> 11100011 & (00000001) = 00000001 , 结果为1, 最后判断的时候写作 (n & (1 << i)) != 0
            //2.如果判断第i位结果是1, 相当于我们要把i位的 1 进行左移31-i位, 写作: 1 << 31-i
            ans ^= (n & (1 << i)) != 0 ? 1 << (31-i) : 0;
            System.out.println(Integer.toBinaryString(ans));
        }
        return ans;
    }
    /**
     * 取模求和
     * 与反转十进制整数使用取模除十累加的方法类似，
     * 十进制：ans = ans * 10 + n % 10; n = n / 10;
     * 二进制：ans = ans * 2 + n % 2; n = n / 2;
     * @param n
     * @return
     */
    public static int reverseBits3(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            // res << 1 等同 res * 2
            // n & 1 等同 n / 2
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
    /**
     * JAVA Integer API
     * @param n
     * @return
     */
    public static int reverseBits2(int n) {
        return Integer.reverse(n);
    }
    public static int reverseBits1(int n) {
        String binaryStr = Integer.toBinaryString(n);
        char[] chars = new char[32];
        int j = 0;
        for(int i = binaryStr.length() - 1; i >= 0; i--){
            chars[j] = binaryStr.charAt(i);
            j++;
        }
        while(j<32){
            chars[j] = '0';
            j++;
        }
        String reverseStr = String.valueOf(chars);
        return Integer.parseInt(reverseStr,2);
    }

    public static void main(String[] args){
        System.out.println(reverseBits(0b00000010100101000001111010011100));
//        System.out.println(reverseBits(0b11111111111111111111111111111101));
//        System.out.println(Integer.toBinaryString(0b0 ^ 0b01));
    }

}
